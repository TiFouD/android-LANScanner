package com.example.lanscanner

import android.content.Context
import android.net.nsd.NsdManager
import android.net.nsd.NsdServiceInfo
import android.util.Log
import io.ktor.client.HttpClient
import io.ktor.client.call.body
import io.ktor.client.engine.cio.CIO
import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
import io.ktor.client.request.get
import io.ktor.client.request.header
import io.ktor.client.request.post
import io.ktor.client.request.setBody
import io.ktor.client.statement.HttpResponse
import io.ktor.http.ContentType
import io.ktor.http.contentType
import io.ktor.serialization.kotlinx.json.json
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.io.Closeable
import java.util.concurrent.CountDownLatch
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import androidx.core.content.edit


private const val TAG = "FreeboxManager"

//<editor-fold desc="Data Classes">
/**
 * Represents a request to authorize the application with the Freebox.
 *
 * @param app_id The application's unique ID.
 * @param app_name The application's name.
 * @param app_version The application's version.
 * @param device_name The name of the device running the application.
 */
@Serializable
data class AuthorizeRequest(
    val app_id: String,
    val app_name: String,
    val app_version: String,
    val device_name: String
)

/**
 * Represents the response to an authorization request.
 *
 * @param success True if the request was successful, false otherwise.
 * @param result The [AuthorizeResult] if the request was successful, null otherwise.
 */
@Serializable
data class AuthorizeResponse(
    val success: Boolean,
    val result: AuthorizeResult? = null
)

/**
 * Contains the application token and track ID from a successful authorization request.
 *
 * @param app_token The application token generated by the Freebox.
 * @param track_id The ID to track the authorization progress.
 */
@Serializable
data class AuthorizeResult(
    val app_token: String,
    val track_id: Int
)

/**
 * Represents the response when tracking authorization progress.
 *
 * @param success True if the request was successful, false otherwise.
 * @param result The [TrackAuthorizationProgressResult] if the request was successful, null otherwise.
 */
@Serializable
data class TrackAuthorizationProgressResponse(
    val success: Boolean,
    val result: TrackAuthorizationProgressResult? = null
)

/**
 * Contains the status and challenge from the authorization progress tracking.
 *
 * @param status The current status of the authorization (e.g., "pending", "granted", "denied", "timeout").
 * @param challenge The challenge string for session opening.
 */
@Serializable
data class TrackAuthorizationProgressResult(
    val status: String,
    val challenge: String
)

/**
 * Represents the response to a login request.
 *
 * @param success True if the request was successful, false otherwise.
 * @param result The [LoginResult] if the request was successful, null otherwise.
 */
@Serializable
data class LoginResponse(
    val success: Boolean,
    val result: LoginResult? = null
)

/**
 * Contains login information, including challenge and session token.
 *
 * @param logged_in True if already logged in, false otherwise.
 * @param challenge The challenge string to be used for password hashing.
 * @param session_token The session token if a session was successfully opened.
 */
@Serializable
data class LoginResult(
    val logged_in: Boolean? = null,
    val challenge: String,
    val session_token: String? = null
)

/**
 * Represents the response containing a list of LAN devices.
 *
 * @param success True if the request was successful, false otherwise.
 * @param result A list of [LanDevice] objects if the request was successful, null otherwise.
 */
@Serializable
data class LanDeviceResponse(
    val success: Boolean,
    val result: List<LanDevice>? = null
)

/**
 * Represents a single LAN device discovered on the network.
 *
 * @param primary_name The primary name of the device.
 * @param l3connectivities A list of [L3Connectivity] objects for the device.
 * @param l2ident The [L2Ident] containing MAC address information.
 */
@Serializable
data class LanDevice(
    val primary_name: String,
    val l3connectivities: List<L3Connectivity>? = null,
    val l2ident: L2Ident? = null
)

/**
 * Represents the Layer 2 identifier of a device, typically its MAC address.
 *
 * @param id The MAC address of the device.
 * @param type The type of the Layer 2 identifier.
 */
@Serializable
data class L2Ident(
    val id: String, // MAC address
    val type: String
)

/**
 * Represents Layer 3 connectivity information for a device.
 *
 * @param addr The IP address.
 * @param active True if the connectivity is active, false otherwise.
 */
@Serializable
data class L3Connectivity(
    val addr: String,
    val active: Boolean
)
//</editor-fold>

/**
 * Manages communication and authorization with a Freebox router.
 *
 * @param context The application context.
 */
@Suppress("DEPRECATION")
class FreeboxManager(private val context: Context) : Closeable {

    private val nsdManager by lazy {
        context.getSystemService(Context.NSD_SERVICE) as NsdManager
    }

    private val httpClient = HttpClient(CIO) {
        install(ContentNegotiation) {
            json(Json {
                ignoreUnknownKeys = true
                prettyPrint = true
            })
        }
    }

    private val sharedPreferences by lazy {
        context.getSharedPreferences("freebox_prefs", Context.MODE_PRIVATE)
    }

    /**
     * The stored application token for Freebox API access.
     */
    var appToken: String?
        get() = sharedPreferences.getString("app_token", null)
        set(value) {
            sharedPreferences.edit { putString("app_token", value) }
        }

    private var sessionToken: String? = null


    /**
     * Discovers a Freebox service on the local network using NSD (Network Service Discovery).
     *
     * @return The [NsdServiceInfo] of the discovered Freebox, or null if not found or an error occurs.
     */
    fun discoverFreebox(): NsdServiceInfo? {
        var serviceInfo: NsdServiceInfo? = null
        val latch = CountDownLatch(1)

        // The listener is declared here so it can be accessed in the 'finally' block
        val discoveryListener = object : NsdManager.DiscoveryListener {
            override fun onDiscoveryStarted(regType: String) {
                Log.d(TAG, "Service discovery started")
            }

            override fun onServiceFound(service: NsdServiceInfo) {
                Log.d(TAG, "Service discovery success: $service")
                if (service.serviceType.contains("_fbx-api._tcp")) {
                    nsdManager.resolveService(service, object : NsdManager.ResolveListener {
                        override fun onResolveFailed(serviceInfo: NsdServiceInfo, errorCode: Int) {
                            Log.e(TAG, "Resolve failed: $errorCode")
                            latch.countDown()
                        }

                        override fun onServiceResolved(resolvedServiceInfo: NsdServiceInfo) {
                            Log.e(TAG, "Resolve Succeeded: $resolvedServiceInfo")
                            serviceInfo = resolvedServiceInfo
                            latch.countDown()
                        }
                    })
                }
            }

            override fun onServiceLost(service: NsdServiceInfo) {
                Log.e(TAG, "service lost: $service")
            }

            override fun onDiscoveryStopped(serviceType: String) {
                Log.i(TAG, "Discovery stopped: $serviceType")
            }

            override fun onStartDiscoveryFailed(serviceType: String, errorCode: Int) {
                Log.e(TAG, "Discovery failed: Error code:$errorCode")
                latch.countDown()
            }

            override fun onStopDiscoveryFailed(serviceType: String, errorCode: Int) {
                Log.e(TAG, "Discovery failed: Error code:$errorCode")
                latch.countDown()
            }
        }

        try {
            nsdManager.discoverServices("_fbx-api._tcp.", NsdManager.PROTOCOL_DNS_SD, discoveryListener)
            latch.await()
        } catch (e: Exception) {
            Log.e(TAG, "Error during service discovery", e)
        } finally {
            Log.d(TAG, "Stopping service discovery (in finally block)")
            nsdManager.stopServiceDiscovery(discoveryListener)
        }

        return serviceInfo
    }

    /**
     * Sends an authorization request to the Freebox to get an application token.
     *
     * @param freeboxApiUrl The base URL of the Freebox API.
     * @return An [AuthorizeResponse] containing the success status and result.
     */
    suspend fun requestAuthorization(freeboxApiUrl: String): AuthorizeResponse {
        val request = AuthorizeRequest(
            app_id = "com.example.lanscanner",
            app_name = "LAN Scanner",
            app_version = "1.0.0",
            device_name = getDeviceName()
        )

        val response: HttpResponse = httpClient.post("$freeboxApiUrl/api/v4/login/authorize/") {
            contentType(ContentType.Application.Json)
            setBody(request)
        }

        val authResponse: AuthorizeResponse = response.body()
        if (authResponse.success) {
            appToken = authResponse.result?.app_token
        }
        return authResponse
    }

    /**
     * Tracks the progress of an authorization request using the provided track ID.
     *
     * @param freeboxApiUrl The base URL of the Freebox API.
     * @param trackId The track ID obtained from the initial authorization request.
     * @return A [TrackAuthorizationProgressResponse] indicating the current status.
     */
    suspend fun trackAuthorizationProgress(freeboxApiUrl: String, trackId: Int): TrackAuthorizationProgressResponse {
        val response: HttpResponse = httpClient.get("$freeboxApiUrl/api/v4/login/authorize/$trackId")
        return response.body()
    }

    /**
     * Opens a session with the Freebox using the stored application token.
     *
     * This involves getting a challenge from the Freebox, hashing it with the app token,
     * and then sending the response to establish a session.
     *
     * @param freeboxApiUrl The base URL of the Freebox API.
     * @return True if the session was successfully opened, false otherwise.
     */
    suspend fun openSession(freeboxApiUrl: String): Boolean {
        // 1. Get challenge
        val loginResponse: LoginResponse = httpClient.get("$freeboxApiUrl/api/v4/login/").body()
        if (!loginResponse.success) return false

        val challenge = loginResponse.result!!.challenge
        val password = hmacSha1(challenge, appToken!!)

        // 2. Send challenge response
        val sessionResponse: LoginResponse = httpClient.post("$freeboxApiUrl/api/v4/login/session/") {
            contentType(ContentType.Application.Json)
            setBody(mapOf("app_id" to "com.example.lanscanner", "password" to password))
        }.body()

        if (sessionResponse.success) {
            sessionToken = sessionResponse.result?.session_token
        }
        return sessionResponse.success
    }

    /**
     * Retrieves a list of devices connected to the Freebox's local area network.
     *
     * Requires an active session token.
     *
     * @param freeboxApiUrl The base URL of the Freebox API.
     * @return A list of [DeviceInfo] objects representing the connected devices, or an empty list if no session or no devices are found.
     */
    suspend fun getLanDevices(freeboxApiUrl: String): List<DeviceInfo> {
        if (sessionToken == null) return emptyList()

        val response: LanDeviceResponse = httpClient.get("$freeboxApiUrl/api/v4/lan/browser/pub/") {
            header("X-Fbx-App-Auth", sessionToken)
        }.body()

        return response.result?.mapNotNull { device ->
            val activeIp = device.l3connectivities?.find { it.active }?.addr
            val macAddress = device.l2ident?.id
            if (activeIp != null && macAddress != null) {
                DeviceInfo(
                    activeIp,
                    device.primary_name,
                mac = macAddress
                )
            } else {
                null
            }
        } ?: emptyList()
    }

    /**
     * Retrieves the device name of the current Android device.
     *
     * @return The device name (e.g., "Samsung Galaxy S21").
     */
    private fun getDeviceName(): String {
        val manufacturer = android.os.Build.MANUFACTURER
        val model = android.os.Build.MODEL

        return if (model.lowercase().startsWith(manufacturer.lowercase())) {
            model
        } else {
            "$manufacturer $model"
        }
    }

    /**
     * Computes the HMAC-SHA1 hash of a given value using a secret key.
     *
     * @param value The string to be hashed.
     * @param key The secret key for the HMAC.
     * @return The hexadecimal string representation of the HMAC-SHA1 hash.
     */
    private fun hmacSha1(value: String, key: String): String {
        val keySpec = SecretKeySpec(key.toByteArray(), "HmacSHA1")
        val mac = Mac.getInstance("HmacSHA1")
        mac.init(keySpec)
        val bytes = mac.doFinal(value.toByteArray())
        return bytes.joinToString("") { "%02x".format(it) }
    }

    /**
     * Clears the stored Freebox authorization data (app token and session token).
     */
    fun forgetAuthorization() {
        Log.d(TAG, "Forgetting stored authorization data")
        appToken = null
        sessionToken = null
    }

    /**
     * Closes the underlying HTTP client.
     */
    override fun close() {
        Log.d(TAG, "Closing HttpClient")
        httpClient.close()
    }
}